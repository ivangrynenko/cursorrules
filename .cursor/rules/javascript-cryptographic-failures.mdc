---
description: Detect and prevent cryptographic failures in JavaScript applications as defined in OWASP Top 10:2021-A02
globs: **/*.js, **/*.jsx, **/*.ts, **/*.tsx, !**/node_modules/**, !**/dist/**, !**/build/**, !**/coverage/**
---
# JavaScript Cryptographic Failures (OWASP A02:2021)

> Priority: high Â· Version: 1.0

## Applies To
- `**/*.js`
- `**/*.jsx`
- `**/*.ts`
- `**/*.tsx`
- `!**/node_modules/**`
- `!**/dist/**`
- `!**/build/**`
- `!**/coverage/**`

## Required Checks

- Using weak hashing algorithms (MD5/SHA1). Use SHA-256 or stronger algorithms.
- Potential hardcoded credentials detected. Store secrets in environment variables or a secure vault.
- Using Math.random() for security purposes. Use crypto.randomBytes() or Web Crypto API for cryptographic operations.
- Using deprecated/insecure SSL/TLS protocol versions. Use TLS 1.2+ for secure communications.
- SSL certificate validation is disabled. Always validate certificates in production environments.
- Using insecure encryption cipher or mode. Use AES with GCM or CBC mode with proper padding.
- Using insufficient key length for asymmetric encryption. RSA keys should be at least 2048 bits, preferably 4096 bits.
- Using plain hashing for passwords. Use dedicated password hashing functions like bcrypt, scrypt, or PBKDF2.
- Ensure you're using a proper random salt with password hashing functions.
- Cookies with sensitive data should have secure and httpOnly flags enabled.
- Performing sensitive cryptographic operations on the client side. Move encryption/decryption logic to the server.
- JWT implementation missing expiration or using weak algorithm. Set expiresIn and use a strong algorithm.
- Using potentially weak pseudorandom number generator. Use crypto.randomBytes() for cryptographic security.
- Storing sensitive data in browser storage. Use secure HttpOnly cookies for authentication tokens.
- Weak password validation. Require at least 12 characters with a mix of uppercase, lowercase, numbers, and special characters.

## Recommendations

**JavaScript Cryptography Best Practices:**

1. **Secure Password Storage:**
   - Use dedicated password hashing algorithms:
     ```javascript
     // Node.js with bcrypt
     const bcrypt = require('bcrypt');
     const saltRounds = 12;
     const hashedPassword = await bcrypt.hash(password, saltRounds);
     
     // Verify password
     const match = await bcrypt.compare(password, hashedPassword);
     ```
   - Or use Argon2 (preferred) or PBKDF2 with sufficient iterations:
     ```javascript
     // Node.js with crypto
     const crypto = require('crypto');
     
     function hashPassword(password) {
       const salt = crypto.randomBytes(16);
       const hash = crypto.pbkdf2Sync(password, salt, 310000, 32, 'sha256');
       return { salt: salt.toString('hex'), hash: hash.toString('hex') };
     }
     ```

2. **Secure Random Number Generation:**
   - In Node.js:
     ```javascript
     const crypto = require('crypto');
     const randomBytes = crypto.randomBytes(32); // 256 bits of randomness
     ```
   - In browsers:
     ```javascript
     const array = new Uint8Array(32);
     window.crypto.getRandomValues(array);
     ```

3. **Secure Communications:**
   - Use TLS 1.2+ for all communications:
     ```javascript
     // Node.js HTTPS server
     const https = require('https');
     const fs = require('fs');
     
     const options = {
       key: fs.readFileSync('private-key.pem'),
       cert: fs.readFileSync('certificate.pem'),
       minVersion: 'TLSv1.2'
     };
     
     https.createServer(options, (req, res) => {
       res.writeHead(200);
       res.end('Hello, world!');
     }).listen(443);
     ```
   - Always validate certificates:
     ```javascript
     // Node.js HTTPS request
     const https = require('https');
     
     const options = {
       hostname: 'example.com',
       port: 443,
       path: '/',
       method: 'GET',
       rejectUnauthorized: true // Default, but explicitly set for clarity
     };
     
     const req = https.request(options, (res) => {
       // Handle response
     });
     ```

4. **Proper Key Management:**
   - Never hardcode secrets in source code
   - Use environment variables or secure vaults:
     ```javascript
     // Node.js with dotenv
     require('dotenv').config();
     const apiKey = process.env.API_KEY;
     ```
   - Consider using dedicated key management services

5. **Secure Encryption:**
   - Use authenticated encryption (AES-GCM):
     ```javascript
     // Node.js crypto
     const crypto = require('crypto');
     
     function encrypt(text, masterKey) {
       const iv = crypto.randomBytes(12);
       const cipher = crypto.createCipheriv('aes-256-gcm', masterKey, iv);
       
       let encrypted = cipher.update(text, 'utf8', 'hex');
       encrypted += cipher.final('hex');
       
       const authTag = cipher.getAuthTag().toString('hex');
       
       return {
         iv: iv.toString('hex'),
         encrypted,
         authTag
       };
     }
     
     function decrypt(encrypted, masterKey) {
       const decipher = crypto.createDecipheriv(
         'aes-256-gcm',
         masterKey,
         Buffer.from(encrypted.iv, 'hex')
       );
       
       decipher.setAuthTag(Buffer.from(encrypted.authTag, 'hex'));
       
       let decrypted = decipher.update(encrypted.encrypted, 'hex', 'utf8');
       decrypted += decipher.final('utf8');
       
       return decrypted;
     }
     ```

6. **Secure Cookie Handling:**
   - Set secure and httpOnly flags:
     ```javascript
     // Express.js
     res.cookie('session', sessionId, {
       httpOnly: true,
       secure: true,
       sameSite: 'strict',
       maxAge: 3600000 // 1 hour
     });
     ```

7. **JWT Security:**
   - Use strong algorithms and set expiration:
     ```javascript
     // Node.js with jsonwebtoken
     const jwt = require('jsonwebtoken');
     
     const token = jwt.sign(
       { userId: user.id },
       process.env.JWT_SECRET,
       { 
         expiresIn: '1h',
         algorithm: 'HS256'
       }
     );
     ```
   - Validate tokens properly:
     ```javascript
     try {
       const decoded = jwt.verify(token, process.env.JWT_SECRET);
       // Process request with decoded data
     } catch (err) {
       // Handle invalid token
     }
     ```

8. **Constant-Time Comparison:**
   - Use crypto.timingSafeEqual for comparing secrets:
     ```javascript
     const crypto = require('crypto');
     
     function safeCompare(a, b) {
       const bufA = Buffer.from(a);
       const bufB = Buffer.from(b);
       
       // Ensure the buffers are the same length to avoid timing attacks
       // based on length differences
       if (bufA.length !== bufB.length) {
         return false;
       }
       
       return crypto.timingSafeEqual(bufA, bufB);
     }
     ```

## Validation

- Using secure password hashing algorithm.
- Using cryptographically secure random number generation.
- Using secure TLS configuration.
- Properly validating SSL certificates.

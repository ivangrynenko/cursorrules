---
description: Detect and prevent cryptographic failures in Python applications as defined in OWASP Top 10:2021-A02
globs: *.py
alwaysApply: false
---
# Python Cryptographic Failures Security Standards (OWASP A02:2021)

This rule enforces security best practices to prevent cryptographic failures in Python applications, as defined in OWASP Top 10:2021-A02.

> Priority: high Â· Version: 1.0

## Applies To
- `*.py`

## Trigger Conditions
- Files matching pattern `\.(py)$`
- Paths matching `.*`

## Required Checks

- Using weak hashing algorithms (MD5/SHA1). Use SHA-256 or stronger algorithms from the hashlib or cryptography packages.
- Potential hardcoded credentials detected. Store secrets in environment variables or a secure vault.
- Using Python's standard random module for security purposes. Use secrets module or cryptography.hazmat.primitives.asymmetric for cryptographic operations.
- Using deprecated/insecure SSL/TLS protocol versions. Use TLS 1.2+ (ssl.PROTOCOL_TLS_CLIENT with minimum version set).
- SSL certificate validation is disabled. Always validate certificates in production environments.
- Using insecure encryption cipher or mode. Use AES with GCM or CBC mode with proper padding.
- Using insufficient key length for asymmetric encryption. RSA keys should be at least 2048 bits, preferably 4096 bits.
- Using plain hashing for passwords. Use dedicated password hashing functions like bcrypt, Argon2, or PBKDF2.
- Ensure you're using a proper random salt with password hashing functions.
- Cookies with sensitive data should have secure and httponly flags enabled.

## Recommendations

**Python Cryptography Best Practices:**

1. **Secure Password Storage:**
   - Use dedicated password hashing algorithms:
     ```python
     import bcrypt
     hashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(rounds=12))
     ```
   - Or use Argon2 (preferred) or PBKDF2 with sufficient iterations:
     ```python
     from argon2 import PasswordHasher
     ph = PasswordHasher()
     hash = ph.hash(password)
     ```

2. **Secure Random Number Generation:**
   - Use the `secrets` module for cryptographic operations:
     ```python
     import secrets
     token = secrets.token_hex(32)  # 256 bits of randomness
     ```
   - For cryptographic keys, use proper key generation functions:
     ```python
     from cryptography.hazmat.primitives.asymmetric import rsa
     private_key = rsa.generate_private_key(public_exponent=65537, key_size=4096)
     ```

3. **Secure Communications:**
   - Use TLS 1.2+ for all communications:
     ```python
     import ssl
     context = ssl.create_default_context()
     context.minimum_version = ssl.TLSVersion.TLSv1_2
     ```
   - Always validate certificates:
     ```python
     import requests
     response = requests.get('https://example.com', verify=True)
     ```

4. **Proper Key Management:**
   - Never hardcode secrets in source code
   - Use environment variables or secure vaults:
     ```python
     import os
     api_key = os.environ.get('API_KEY')
     ```
   - Consider using dedicated key management services

5. **Secure Encryption:**
   - Use high-level libraries like `cryptography`:
     ```python
     from cryptography.fernet import Fernet
     key = Fernet.generate_key()
     f = Fernet(key)
     encrypted = f.encrypt(data)
     ```
   - For lower-level needs, use authenticated encryption (AES-GCM):
     ```python
     from cryptography.hazmat.primitives.ciphers.aead import AESGCM
     key = AESGCM.generate_key(bit_length=256)
     aesgcm = AESGCM(key)
     nonce = os.urandom(12)
     encrypted = aesgcm.encrypt(nonce, data, associated_data)
     ```

6. **Secure Cookie Handling:**
   - Set secure and httponly flags:
     ```python
     # Flask example
     response.set_cookie('session', session_id, httponly=True, secure=True, samesite='Lax')
     ```
   - Use signed cookies or tokens:
     ```python
     # Django example - uses signed cookies by default
     request.session['user_id'] = user.id
     ```

7. **Input Validation:**
   - Validate all cryptographic inputs
   - Use constant-time comparison for secrets:
     ```python
     import hmac
     def constant_time_compare(a, b):
         return hmac.compare_digest(a, b)
     ```

## Validation

- Using secure password hashing algorithm.
- Using cryptographically secure random number generation.
- Using secure TLS configuration.
- Properly validating SSL certificates.

---
description: Detect and prevent injection vulnerabilities in Python applications as defined in OWASP Top 10:2021-A03
globs: *.py, *.ini, *.cfg, *.yml, *.yaml, *.json, *.toml
alwaysApply: false
---
# Python Injection Security Standards (OWASP A03:2021)

This rule enforces security best practices to prevent injection vulnerabilities in Python applications, as defined in OWASP Top 10:2021-A03.

> Priority: high Â· Version: 1.0

## Applies To
- `*.py`
- `*.ini`
- `*.cfg`
- `*.yml`
- `*.yaml`
- `*.json`
- `*.toml`

## Trigger Conditions
- Files matching pattern `\.(py)$`
- Paths matching `.*`

## Required Checks

- Potential SQL injection vulnerability. Use parameterized queries with placeholders instead of string concatenation.
- Potential SQL injection vulnerability. Use parameterized queries with placeholders instead of string formatting.
- Potential command injection vulnerability. Never use string concatenation or formatting with shell commands. Use subprocess with shell=False and pass arguments as a list.
- Using shell=True with subprocess functions is dangerous and can lead to command injection. Use shell=False (default) and pass arguments as a list.
- Potential XSS vulnerability. Ensure all template variables are properly escaped. Avoid using 'autoescape off' in templates.
- Potential XSS vulnerability. Ensure all user-supplied data is properly escaped before rendering in templates.
- Potential path traversal vulnerability. Validate and sanitize file paths before opening files. Consider using os.path.abspath and os.path.normpath.
- Potential LDAP injection vulnerability. Use proper LDAP escaping for user-supplied input in LDAP queries.
- Potential NoSQL injection vulnerability. Use parameterized queries or proper escaping for MongoDB queries.
- Potential template injection or code injection vulnerability. Avoid using eval() or exec() with user input, and ensure template variables are properly validated.

## Recommendations

**Python Injection Prevention Best Practices:**

1. **SQL Injection Prevention:**
   - Use parameterized queries (prepared statements) with placeholders:
     ```python
     # Safe SQL query with parameters
     cursor.execute("SELECT * FROM users WHERE username = %s AND password = %s", (username, password))
     
     # Django ORM (safe by default)
     User.objects.filter(username=username, password=password)
     
     # SQLAlchemy (safe by default)
     session.query(User).filter(User.username == username, User.password == password)
     ```
   - Use ORM frameworks when possible (Django ORM, SQLAlchemy)
   - Apply proper input validation and sanitization

2. **Command Injection Prevention:**
   - Never use shell=True with subprocess functions
   - Pass command arguments as a list, not a string:
     ```python
     # Safe command execution
     subprocess.run(["ls", "-l", user_dir], shell=False)
     ```
   - Use shlex.quote() if you must include user input in shell commands
   - Consider using safer alternatives like Python libraries instead of shell commands

3. **XSS Prevention:**
   - Use template auto-escaping (enabled by default in modern frameworks)
   - Explicitly escape user input before rendering:
     ```python
     # Django
     from django.utils.html import escape
     safe_data = escape(user_input)
     
     # Flask/Jinja2
     from markupsafe import escape
     safe_data = escape(user_input)
     ```
   - Use Content-Security-Policy headers
   - Validate input against allowlists

4. **Path Traversal Prevention:**
   - Validate and sanitize file paths:
     ```python
     import os
     safe_path = os.path.normpath(os.path.join(safe_base_dir, user_filename))
     if not safe_path.startswith(safe_base_dir):
         raise ValueError("Invalid path")
     ```
   - Use os.path.abspath() and os.path.normpath()
   - Implement proper access controls
   - Consider using libraries like Werkzeug's secure_filename()

5. **NoSQL Injection Prevention:**
   - Use parameterized queries or query builders
   - Validate input against schemas
   - Apply proper type checking
     ```python
     # Safe MongoDB query
     collection.find({"username": username, "status": "active"})
     ```

6. **Template Injection Prevention:**
   - Avoid using eval() or exec() with user input
   - Use sandboxed template engines
   - Limit template functionality to what's necessary
   - Apply proper input validation

## Validation

- Using parameterized queries or ORM for database access.
- Using subprocess with arguments as a list (safe pattern).
- Implementing input validation or sanitization.
- Using safe file path handling techniques.

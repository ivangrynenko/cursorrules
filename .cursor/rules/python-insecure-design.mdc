---
description: Detect and prevent insecure design patterns in Python applications as defined in OWASP Top 10:2021-A04
globs: *.py, *.ini, *.cfg, *.yml, *.yaml, *.json, *.toml
alwaysApply: false
---
# Python Insecure Design Security Standards (OWASP A04:2021)

This rule enforces security best practices to prevent insecure design vulnerabilities in Python applications, as defined in OWASP Top 10:2021-A04.

> Priority: high Â· Version: 1.0

## Applies To
- `*.py`
- `*.ini`
- `*.cfg`
- `*.yml`
- `*.yaml`
- `*.json`
- `*.toml`

## Trigger Conditions
- Files matching pattern `\.(py)$`
- Paths matching `.*`

## Required Checks

- Function lacks input validation. Consider implementing validation for all user-supplied inputs.
- Hardcoded business rules detected. Consider using configuration files or database-driven rules for better maintainability.
- API endpoint lacks rate limiting. Consider implementing rate limiting to prevent abuse.
- Insecure default configuration detected. Ensure debug/development modes are disabled in production.
- Consider implementing proper error handling with try-except blocks for operations that might fail.
- Potential insecure direct object reference. Validate user's permission to access the requested object.
- Endpoint lacks authentication checks. Consider adding authentication requirements for sensitive operations.
- Exception caught without proper logging. Implement proper logging for exceptions to aid in debugging and monitoring.
- File upload functionality detected. Ensure proper validation of file types, sizes, and implement virus scanning if applicable.
- Consider adding security headers (Content-Security-Policy, X-Content-Type-Options, etc.) to HTTP responses.

## Recommendations

**Python Secure Design Best Practices:**

1. **Implement Defense in Depth:**
   - Layer security controls throughout your application
   - Don't rely on a single security mechanism
   - Assume that each security layer can be bypassed

2. **Use Secure Defaults:**
   - Start with secure configurations by default
   - Require explicit opt-in for less secure options
   - Example for Flask:
     ```python
     app.config.update(
         SESSION_COOKIE_SECURE=True,
         SESSION_COOKIE_HTTPONLY=True,
         SESSION_COOKIE_SAMESITE='Lax',
         PERMANENT_SESSION_LIFETIME=timedelta(hours=1)
     )
     ```

3. **Implement Proper Access Control:**
   - Use role-based access control (RBAC)
   - Implement principle of least privilege
   - Validate access at the controller and service layers
   - Example:
     ```python
     @app.route('/admin')
     @roles_required('admin')  # Using Flask-Security
     def admin_dashboard():
         return render_template('admin/dashboard.html')
     ```

4. **Use Rate Limiting:**
   - Protect against brute force and DoS attacks
   - Example with Flask-Limiter:
     ```python
     from flask_limiter import Limiter
     limiter = Limiter(app)
     
     @app.route('/login', methods=['POST'])
     @limiter.limit("5 per minute")
     def login():
         # Login logic
     ```

5. **Implement Proper Error Handling:**
   - Catch and log exceptions appropriately
   - Return user-friendly error messages without exposing sensitive details
   - Example:
     ```python
     try:
         # Operation that might fail
         result = perform_operation(user_input)
     except ValidationError as e:
         logger.warning(f"Validation error: {str(e)}")
         return jsonify({"error": "Invalid input provided"}), 400
     except Exception as e:
         logger.error(f"Unexpected error: {str(e)}", exc_info=True)
         return jsonify({"error": "An unexpected error occurred"}), 500
     ```

6. **Use Configuration Management:**
   - Store configuration in environment variables or secure vaults
   - Use different configurations for development and production
   - Example:
     ```python
     import os
     from dotenv import load_dotenv
     
     load_dotenv()
     
     DEBUG = os.getenv('DEBUG', 'False') == 'True'
     SECRET_KEY = os.getenv('SECRET_KEY')
     DATABASE_URL = os.getenv('DATABASE_URL')
     ```

7. **Implement Proper Logging:**
   - Log security events and exceptions
   - Include contextual information but avoid sensitive data
   - Use structured logging
   - Example:
     ```python
     import logging
     
     logger = logging.getLogger(__name__)
     
     def user_action(user_id, action):
         logger.info("User action", extra={
             "user_id": user_id,
             "action": action,
             "timestamp": datetime.now().isoformat()
         })
     ```

8. **Use Security Headers:**
   - Implement Content-Security-Policy, X-Content-Type-Options, etc.
   - Example with Flask:
     ```python
     from flask_talisman import Talisman
     
     talisman = Talisman(
         app,
         content_security_policy={
             'default-src': "'self'",
             'script-src': "'self'"
         }
     )
     ```

9. **Implement Secure File Handling:**
   - Validate file types, sizes, and content
   - Store files outside the web root
   - Use secure file permissions
   - Example:
     ```python
     import os
     from werkzeug.utils import secure_filename
     
     ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg'}
     MAX_CONTENT_LENGTH = 1 * 1024 * 1024  # 1MB
     
     def allowed_file(filename):
         return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
     
     @app.route('/upload', methods=['POST'])
     def upload_file():
         if 'file' not in request.files:
             return jsonify({"error": "No file part"}), 400
         
         file = request.files['file']
         if file.filename == '':
             return jsonify({"error": "No selected file"}), 400
         
         if file and allowed_file(file.filename):
             filename = secure_filename(file.filename)
             file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
             return jsonify({"success": True}), 200
         
         return jsonify({"error": "File type not allowed"}), 400
     ```

10. **Use Threat Modeling:**
    - Identify potential threats during design phase
    - Implement controls to mitigate identified threats
    - Regularly review and update threat models

## Validation

- Implementing input validation.
- Using proper error handling with try-except blocks.
- Implementing rate limiting for API endpoints.
- Using proper logging mechanisms.

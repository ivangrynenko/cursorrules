---
description: PHP & Drupal Development Standards and Best Practices
globs: *.php, *.module, *.theme, *.inc, *.info, *.install
---
# Enhanced PHP & Drupal Development Standards

Defines comprehensive coding standards and best practices for PHP and Drupal development, with a focus on modern PHP features, Drupal 10+ standards, and modularity.

> Priority: critical Â· Version: 1.5

## Applies To
- `*.php`
- `*.module`
- `*.theme`
- `*.inc`
- `*.info`
- `*.install`

## Trigger Conditions
- Files matching pattern `\.(php|module|inc|install|theme)$`
- Paths matching `web/modules/custom/|web/themes/custom/`

## Required Checks

- Add 'declare(strict_types=1);' at the beginning of PHP files for type safety.
- Use uppercase for TRUE, FALSE, and NULL constants.
- Ensure inline comments begin with a capital letter and end with a period.
- Consider using readonly properties where immutability is required.
- Add return type declarations for all methods to ensure type safety.
- Add #[Override] attribute for overridden methods for clarity.
- Use typed properties with proper nullability for better code maintainability.
- Add type hints and return types for all hooks to leverage PHP's type system.
- Use proper dependency injection with services for better testability and modularity.
- Implement proper form validation in FormBase classes for security.
- Use Drupal's t() function for strings that need translation.
- Use ConfigFactory for configuration management.
- Use short array syntax ([]) instead of array() for consistent code style.
- Put a space between the (type) and the $variable in a cast: (int) $mynumber.
- Remove whitespace from empty lines.
- Remove trailing whitespace at the end of lines.
- Ensure files end with a single newline character.
- Place the opening brace on the same line as the statement for control structures.
- Never use superglobals directly; use Drupal's input methods.
- Use Drupal's database API instead of direct MySQL functions.
- Use 2 spaces for indentation, not tabs.
- Don't use echo; use return values or Drupal's messenger service.
- Use proper DocBlock formatting for documentation.
- Don't use die() or exit(); throw exceptions instead.
- Use $entity->get('field_name')->value instead of getValue() when possible.
- Don't use debug functions in production code; use Drupal's logger instead.
- Use Drupal's DateTimeInterface and DrupalDateTime instead of PHP's DateTime.
- Never use eval() as it poses security risks.
- Use controller classes with route definitions instead of hook_menu() callbacks.
- All PHP files must include proper @file documentation in the docblock.
- Use Drupal's user session handling instead of $_SESSION.
- Theme functions should be replaced with Twig templates in Drupal 8+.
- Use #attached in render arrays instead of drupal_add_js() or drupal_add_css().
- Use proper hook implementation format: module_name_hook_name().
- Specify a single class per use statement. Do not specify multiple classes in a single use statement.
- When importing a class with 'use', do not include a leading backslash (\).
- Non-namespaced global classes (like Exception) must be fully qualified with a leading backslash (\) when used in a namespaced file.
- Modules should place classes inside a custom namespace: Drupal\module_name\...
- Leave an empty line between start of class/interface definition and property/method definition.
- Module namespaces should be Drupal\module_name, not Drupal\ModuleName (camelCase not PascalCase).
- Request attributes added by modules should be prefixed with underscore (e.g., '_context_value').
- Avoid overwriting reserved Symfony or Drupal core request attributes.
- Classes that provide services should use the 'Provider' suffix (e.g., MyServiceProvider).
- Services should use dependency injection through constructor arguments defined in services.yml.

## Recommendations

**PHP/Drupal Development Best Practices:**

### General Code Structure
- **File Structure:** Each PHP file should have the proper structures: <?php tag, namespace declaration (if applicable), use statements, docblock, and implementation.
- **Line Length:** Keep lines under 80 characters whenever possible.
- **Indentation:** Use 2 spaces for indentation, never tabs.
- **Empty Lines:** Use empty lines to separate logical blocks of code, but avoid multiple empty lines.
- **File Endings:** All files must end with a single newline character.

### PHP Language Features
- **PHP Version:** Use PHP 8.3+ features where appropriate.
- **Strict Types:** Use declare(strict_types=1) at the top of files to enforce type safety.
- **Type Hints:** Always use parameter and return type hints.
- **Named Arguments:** Use named arguments for clarity in complex function calls.
- **Attributes:** Use PHP 8 attributes like #[Override] for better code comprehension.
- **Match Expressions:** Prefer match over switch for cleaner conditionals.
- **Null Coalescing:** Use ?? and ??= operators where appropriate.

### Drupal-Specific Standards
- **Fields API:** Use hasField(), get(), and value() methods when working with entity fields.
- **Exception Handling:** Use try/catch for exception handling with proper logging.
- **Database Layer:** Use Drupal's database abstraction layer for all queries.
- **Schema Updates:** Implement hook_update_N() for schema changes during updates.
- **Dependency Injection:** Use services.yml and proper container injection.
- **Routing:** Define routes in routing.yml with proper access checks.
- **Forms:** Extend FormBase or ConfigFormBase with proper validation and submission handling.
- **Entity API:** Follow entity API best practices for loading, creating, and editing entities.
- **Plugins:** Use plugin system appropriately with proper annotations.

### Service & Request Standards
- **Service Naming:** Use descriptive service names and appropriate naming patterns (Provider suffix for service providers).
- **Service Definition:** Define services in the module's *.services.yml file with appropriate tags and arguments.
- **Request Attributes:** When adding attributes to the Request object, prefix custom attributes with underscore (e.g., `_context_value`).
- **Reserved Attributes:** Avoid overwriting core-reserved request attributes like `_system_path`, `_title`, `_account`, `_route`, `_route_object`, `_controller`, `_content`.
- **Service Container:** Use dependency injection rather than the service container directly.
- **Factory Services:** Use factory methods for complex service instantiation.

### Namespace Standards
- **Module Namespace:** Use Drupal\\module_name\\... for all custom module code.
- **PSR-4 Autoloading:** Class in folder module/src/SubFolder should use namespace Drupal\\module_name\\SubFolder.
- **Use Statements:** Each class should have its own use statement; don't combine multiple classes in one use.
- **No Leading Backslash:** Don't add a leading backslash (\\) in use statements.
- **Global Classes:** Global classes (like Exception) must be fully qualified with a leading backslash (\\) when used in a namespaced file.
- **Class Aliasing:** Only alias classes to avoid name collisions, using meaningful names like BarBaz and ThingBaz.
- **String Class Names:** When specifying a class name in a string, use full name including namespace without leading backslash. Prefer single quotes.
- **Class Placement:** A class named Drupal\\module_name\\Foo should be in file module_name/src/Foo.php.

### Security Practices
- **Input Validation:** Always validate and sanitize user input.
- **Access Checks:** Implement proper access checks for all routes and content.
- **CSRF Protection:** Use Form API with proper form tokens for all forms.
- **SQL Injection:** Use parameterized queries with placeholders.
- **XSS Prevention:** Use Xss::filter() or t() with appropriate placeholders.
- **File Security:** Validate uploaded files and restrict access properly.

### Documentation and Comments
- **PHPDoc Blocks:** Document all classes, methods, and properties with proper PHPDoc.
- **Function Comments:** Describe parameters, return values, and exceptions.
- **Inline Comments:** Use meaningful comments for complex logic.
- **Comment Format:** Begin comments with a capital letter and end with a period.
- **API Documentation:** Follow Drupal's API documentation standards.

### Performance
- **Caching:** Implement proper cache tags, contexts, and max-age.
- **Database Queries:** Optimize queries with proper indices and JOINs.
- **Lazy Loading:** Use lazy loading for expensive operations.
- **Batch Processing:** Use batch API for long-running operations.
- **Static Caching:** Implement static caching for repeated operations.

### Testing
- **Unit Tests:** Write PHPUnit tests for business logic.
- **Kernel Tests:** Use kernel tests for integration with Drupal subsystems.
- **Functional Tests:** Implement functional tests for user interactions.
- **Mocking:** Use proper mocking techniques for dependencies.
- **Test Coverage:** Aim for high test coverage of critical functionality.

### API Documentation Examples

#### File Documentation

**Module Files (.module)**
```php
<?php

/**
 * @file
 * Provides [module functionality description].
 */
```

**Install Files (.install)**
```php
<?php

/**
 * @file
 * Install, update and uninstall functions for the [module name] module.
 */
```

**Include Files (.inc)**
```php
<?php

/**
 * @file
 * [Specific functionality] for the [module name] module.
 */
```

**Class Files (in namespaced directories)**
```php
<?php

namespace Drupal\module_name\ClassName;

use Drupal\Core\SomeClass;

/**
 * Provides [class functionality description].
 *
 * [Extended description if needed]
 */
class ClassName implements InterfaceName {
```

#### Function Documentation

**Standard Function**
```php
/**
 * Returns [what the function returns or does].
 *
 * [Additional explanation if needed]
 *
 * @param string $param1
 *   Description of parameter.
 * @param int $param2
 *   Description of parameter.
 *
 * @return array
 *   Description of returned data.
 *
 * @throws \Exception
 *   Exception thrown when [condition].
 *
 * @see related_function()
 */
function module_function_name($param1, $param2) {
```

**Hook Implementation**
```php
/**
 * Implements hook_form_alter().
 */
function module_name_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
```

**Update Hook**
```php
/**
 * Implements hook_update_N().
 *
 * [Description of what the update does].
 */
function module_name_update_8001() {
```

#### Class Documentation

**Class Properties**
```php
/**
 * The entity type manager.
 *
 * @var \Drupal\Core\Entity\EntityTypeManagerInterface
 */
protected $entityTypeManager;
```

**Method Documentation**
```php
/**
 * Gets entities of a specific type.
 *
 * @param string $entity_type
 *   The entity type ID.
 * @param array $conditions
 *   (optional) An array of conditions to match. Defaults to an empty array.
 *
 * @return \Drupal\Core\Entity\EntityInterface[]
 *   An array of entity objects indexed by their IDs.
 *
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 *   Thrown if the entity type doesn't exist.
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 *   Thrown if the storage handler couldn't be loaded.
 */
public function getEntities(string $entity_type, array $conditions = []): array {
```

**Interface Method**
```php
/**
 * Implements \SomeInterface::methodName().
 */
public function methodName() {
```

#### Namespace Examples

**Using Classes From Other Namespaces**
```php
namespace Drupal\mymodule\Tests\Foo;

use Drupal\simpletest\WebTestBase;

/**
 * Tests that the foo bars.
 */
class BarTest extends WebTestBase {
```

**Class Aliasing for Name Collisions**
```php
use Foo\Bar\Baz as BarBaz;
use Stuff\Thing\Baz as ThingBaz;

/**
 * Tests stuff for the whichever.
 */
function test() {
  $a = new BarBaz(); // This will be Foo\Bar\Baz
  $b = new ThingBaz(); // This will be Stuff\Thing\Baz
}
```

**Using Global Classes in Namespaced Files**
```php
namespace Drupal\Subsystem;

// Bar is a class in the Drupal\Subsystem namespace in another file.
// It is already available without any importing.

/**
 * Defines a Foo.
 */
class Foo {

  /**
   * Constructs a new Foo object.
   */
  public function __construct(Bar $b) {
    // Global classes must be prefixed with a \ character.
    $d = new \DateTime();
  }
}
```

#### Service Definition Example

**services.yml File**
```yaml
services:
  mymodule.my_service:
    class: Drupal\mymodule\MyService
    arguments: ['@entity_type.manager', '@current_user']
    tags:
      - { name: cache.context }
```

**Request Attribute Handling**
```php
// Correctly adding a request attribute (with underscore prefix)
\Drupal::request()->attributes->set('_context_value', $myvalue);

// Correctly retrieving a request attribute
$contextValue = \Drupal::request()->attributes->get('_context_value');
```

## Validation

- Ensure each custom module has a required .info.yml file.
- Ensure module has .module file if hooks are implemented.
- Place form classes in the Form directory for organization.
- Implement proper exception handling in catch blocks.
- Namespace should be Drupal\ModuleName\...
- Follow PSR-4 for class naming and organization.
- Use nullable return types (e.g., ?string) instead of type|null in docblocks.
- Call parent::__construct() if extending a class with a constructor.
- Use camelCase for method names (e.g., getId instead of get_id).
- Add proper @file docblock for PHP files.
- Replace 'hook_' prefix with your module name in hook implementations.
- DocBlock tags should be properly aligned with leading asterisks.
- Use proper data types in @param tags (array, bool, int, string, etc.).
- Use proper data types in @return tags (array, bool, int, string, etc.).
- Parameter description should be separated by at least 3 spaces from the param type/name.
- Theme functions should include @ingroup themeable in their docblock.
- @code blocks should specify the language (e.g., @code php).
- Namespaces should start with 'Drupal\'.
- Every module using services should have a services.yml file.
- Service providers should be in the module's root namespace (src/ directory).

---
description: Detect and prevent broken access control vulnerabilities in Python applications as defined in OWASP Top 10:2021-A01
globs: *.py
alwaysApply: false
---
# Python Broken Access Control Security Standards (OWASP A01:2021)

This rule enforces security best practices to prevent broken access control vulnerabilities in Python applications, as defined in OWASP Top 10:2021-A01.

> Priority: 90 Â· Version: 1.0

## Applies To
- `*.py`

## Trigger Conditions
- Files matching pattern `\.(py)$`
- Paths matching `.*`

## Required Checks

- Flask route lacks access control. Consider using @login_required or checking user permissions within the function.
- Django class-based view lacks access control mixins. Consider using LoginRequiredMixin, PermissionRequiredMixin, or UserPassesTestMixin.
- Potential insecure direct object reference (IDOR). Validate that the current user has permission to access this object.
- Hardcoded role checks can be fragile. Consider using a permission system or role-based access control framework.
- FastAPI endpoint lacks security dependencies. Consider using Depends(get_current_user) or similar security dependencies.
- Dangerous admin/debug flags in request parameters could bypass access control. Remove or secure these backdoors.
- Extremely dangerous use of eval() or exec() with user input can lead to code execution. Avoid these functions entirely.
- API endpoint may lack access control. Ensure proper authentication and authorization checks are implemented.
- Setting session variables directly from request data without validation can lead to session-based access control bypasses.
- Form or view appears to be missing CSRF protection. Ensure CSRF tokens are properly implemented.

## Recommendations

**Python Access Control Best Practices:**

1. **Framework-Specific Controls:**
   - **Django**: Use built-in authentication and permission decorators/mixins
     - `@login_required`, `LoginRequiredMixin`
     - `@permission_required`, `PermissionRequiredMixin`
     - `UserPassesTestMixin` for custom permission logic
   - **Flask**: Use Flask-Login or similar extensions
     - `@login_required` decorator
     - `current_user.is_authenticated` checks
     - Role-based access control with Flask-Principal
   - **FastAPI**: Use dependency injection for security
     - `Depends(get_current_user)` pattern
     - OAuth2 with `Security(oauth2_scheme)`
     - JWT validation middleware

2. **General Access Control Principles:**
   - Implement access control at the server side, never rely on client-side checks
   - Use deny-by-default approach (whitelist vs blacklist)
   - Implement proper session management
   - Apply principle of least privilege
   - Use contextual access control (time, location, device-based restrictions when appropriate)

3. **Object-Level Authorization:**
   - Validate user has permission to access specific resources
   - Implement row-level security for database access
   - Use UUIDs instead of sequential IDs when possible
   - Always verify ownership or permission before allowing operations on objects

4. **API Security:**
   - Implement proper authentication for all API endpoints
   - Use token-based authentication with proper validation
   - Apply rate limiting to prevent brute force attacks
   - Implement proper CORS configuration
   - Log and monitor access control failures

5. **Testing Access Control:**
   - Write tests specifically for authorization logic
   - Test vertical access control (different permission levels)
   - Test horizontal access control (same permission level, different users)
   - Verify access control works after session timeout/expiration

## Validation

- Using Django's built-in access control mechanisms.
- Implementing proper Flask authentication checks.
- Implementing object-level permission checks.
- Using FastAPI's security dependency injection.

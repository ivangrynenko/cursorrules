---
description: Identify and prevent hardcoded secrets, tokens, and credentials across source files and configuration
globs: "*"
alwaysApply: true
---
# Secret Detection and Secure Handling

Use this guidance whenever code, configuration, or infrastructure definitions might expose credentials or other sensitive values.

> Priority: high · Version: 1.0 · Tags: security, secrets, sensitive-data, language:all

## Applies To
- Application source files, infrastructure code, build scripts, and generated configuration.
- Environment files (`.env`, `.env.*`, `.ini`, `.cfg`, `.yml/.yaml`, `.json`, `.properties`).
- Key material (`*.pem`, `*.key`, `*.crt`), API client files, and deployment manifests.

## Trigger Indicators
- High-entropy strings or provider-specific prefixes (AWS, GCP, Azure, GitHub, Stripe, Slack, Twilio, etc.).
- Inline passwords, tokens, signing keys, or certificates.
- Database connection strings containing credentials or host/IP pairs.
- Environment variables committed to version control or CI artifacts.

## Required Checks
- Remove or refactor any discovered secrets immediately; revoke and rotate exposed credentials before closing the task.
- Move secret values into managed storage (environment variables, secret managers, platform identity) and document the new source of truth.
- Update `.gitignore`, `.cursorignore`, and CI artifact policies to prevent reintroduction of the leaked file type or pattern.
- Capture incident details (secret owner, scope of exposure, rotation status) in the ticket or change log.

## Recommendations
- Adopt dedicated secret management services (AWS Secrets Manager, Azure Key Vault, GCP Secret Manager, HashiCorp Vault, Doppler, sealed secrets).
- Prefer runtime injection via environment variables, service accounts, workload identity, or CI/CD vault integrations.
- Add automated scanners (git-secrets, detect-secrets, trufflehog, Gitleaks) to pre-commit hooks and pipeline stages.
- Limit log verbosity and scrub sensitive values from monitoring, tracing, and analytics exports.
- Establish rotation cadences (e.g., 90-day maximum) with alerting when credentials near expiry or are reused.
- Provide team training and playbooks covering discovery, rotation, and cleanup steps.

## Positive Signals
- Usage of `os.environ`, `process.env`, or secrets manager clients instead of literals.
- Configuration referencing secret identifiers (`vault://`, `aws-secrets://`, `sops://`, `kubernetes.io/secret`) rather than raw values.
- Repository policies or tests that enforce secret scanning and remediation.
- Ignore rules preventing accidental commits of `.env`, `*.pem`, `*secret*`, or similar files.

## Automation Tips
- Maintain allowlists of known dummy keys to reduce false positives without suppressing alerts broadly.
- Track recurring false positives centrally and share updates across projects installing this rule set.
- Version control secret scanning baselines to ensure new matches are reviewed intentionally.

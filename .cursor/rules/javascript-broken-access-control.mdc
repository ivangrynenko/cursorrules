---
description: Detect and prevent broken access control patterns in JavaScript applications as defined in OWASP Top 10:2021-A01
globs: **/*.js, **/*.jsx, **/*.ts, **/*.tsx, !**/node_modules/**, !**/dist/**, !**/build/**, !**/coverage/**
---
# JavaScript Broken Access Control (OWASP A01:2021)

This rule identifies and prevents broken access control vulnerabilities in JavaScript applications, focusing on both browser and Node.js environments, as defined in OWASP Top 10:2021-A01.

> Priority: high Â· Version: 1.0

## Applies To
- `**/*.js`
- `**/*.jsx`
- `**/*.ts`
- `**/*.tsx`
- `!**/node_modules/**`
- `!**/dist/**`
- `!**/build/**`
- `!**/coverage/**`

## Required Checks

- Potential Insecure Direct Object Reference (IDOR) vulnerability. User-supplied IDs should be validated against user permissions before database access.
- Route handler appears to be missing authorization checks. Implement proper access control to verify user permissions before processing requests.
- Hardcoded JWT secret detected. Store JWT secrets securely in environment variables or a configuration manager.
- Authorization logic implemented on client-side. Client-side authorization checks can be bypassed. Always enforce authorization on the server.
- Wildcard CORS policy detected. This allows any domain to make cross-origin requests. Restrict CORS to specific trusted domains.
- Administrative function appears to be missing role or permission checks. Implement proper authorization checks to restrict access to administrative functions.
- Login function appears to be missing rate limiting. Implement rate limiting to prevent brute force attacks.
- Potential horizontal privilege escalation vulnerability. Ensure the requested resource belongs to the authenticated user.
- Route may be missing CSRF protection. Implement CSRF tokens for state-changing operations to prevent cross-site request forgery attacks.
- Potential path traversal vulnerability in file access. Validate and sanitize user-supplied paths to prevent directory traversal attacks.
- Express application may be missing authentication middleware. Implement proper authentication to secure your application.
- Cookies appear to be set without security attributes. Set the secure, httpOnly, and sameSite attributes for sensitive cookies.
- Hidden form fields used for access control. Never rely on hidden form fields for access control decisions as they can be easily manipulated.
- Client-side conditional routing based on user roles detected. Always enforce access control on the server side as client-side checks can be bypassed.
- Access control based on URL parameters detected. Never use request parameters for access control decisions as they can be easily manipulated.

## Recommendations

**JavaScript Access Control Best Practices:**

1. **Implement Server-Side Access Control**
   - Never rely solely on client-side access control
   - Use middleware to enforce authorization
   - Example Express.js middleware:
     ```javascript
     // Role-based access control middleware
     function requireRole(role) {
       return (req, res, next) => {
         if (!req.user) {
           return res.status(401).json({ error: 'Authentication required' });
         }
         
         if (!req.user.roles.includes(role)) {
           return res.status(403).json({ error: 'Insufficient permissions' });
         }
         
         next();
       };
     }
     
     // Usage in routes
     app.get('/admin/users', requireRole('admin'), (req, res) => {
       // Handle admin-only route
     });
     ```

2. **Implement Proper Authentication**
   - Use established authentication libraries
   - Implement multi-factor authentication for sensitive operations
   - Example with Passport.js:
     ```javascript
     const passport = require('passport');
     const JwtStrategy = require('passport-jwt').Strategy;
     
     passport.use(new JwtStrategy(jwtOptions, async (payload, done) => {
       try {
         const user = await User.findById(payload.sub);
         if (!user) {
           return done(null, false);
         }
         return done(null, user);
       } catch (error) {
         return done(error, false);
       }
     }));
     
     // Protect routes
     app.get('/protected', 
       passport.authenticate('jwt', { session: false }),
       (req, res) => {
         res.json({ success: true });
       }
     );
     ```

3. **Implement Proper Authorization**
   - Use attribute or role-based access control
   - Check permissions for each protected resource
   - Example:
     ```javascript
     // Permission-based middleware
     function checkPermission(permission) {
       return async (req, res, next) => {
         try {
           // Get user permissions from database
           const userPermissions = await getUserPermissions(req.user.id);
           
           if (!userPermissions.includes(permission)) {
             return res.status(403).json({ error: 'Permission denied' });
           }
           
           next();
         } catch (error) {
           next(error);
         }
       };
     }
     
     // Usage
     app.post('/articles', 
       authenticate,
       checkPermission('article:create'), 
       (req, res) => {
         // Create article
       }
     );
     ```

4. **Protect Against Insecure Direct Object References (IDOR)**
   - Validate that the requested resource belongs to the user
   - Use indirect references or access control lists
   - Example:
     ```javascript
     app.get('/documents/:id', authenticate, async (req, res) => {
       try {
         const document = await Document.findById(req.params.id);
         
         // Check if document exists
         if (!document) {
           return res.status(404).json({ error: 'Document not found' });
         }
         
         // Check if user owns the document or has access
         if (document.userId !== req.user.id && 
             !(await userHasAccess(req.user.id, document.id))) {
           return res.status(403).json({ error: 'Access denied' });
         }
         
         res.json(document);
       } catch (error) {
         res.status(500).json({ error: error.message });
       }
     });
     ```

5. **Implement Proper CORS Configuration**
   - Never use wildcard (*) in production
   - Whitelist specific trusted origins
   - Example:
     ```javascript
     const cors = require('cors');
     
     const corsOptions = {
       origin: ['https://trusted-app.com', 'https://admin.trusted-app.com'],
       methods: ['GET', 'POST', 'PUT', 'DELETE'],
       allowedHeaders: ['Content-Type', 'Authorization'],
       credentials: true,
       maxAge: 86400 // 24 hours
     };
     
     app.use(cors(corsOptions));
     ```

6. **Implement CSRF Protection**
   - Use anti-CSRF tokens for state-changing operations
   - Validate the token on the server
   - Example with csurf:
     ```javascript
     const csrf = require('csurf');
     
     // Setup CSRF protection
     const csrfProtection = csrf({ cookie: true });
     
     // Generate CSRF token
     app.get('/form', csrfProtection, (req, res) => {
       res.render('form', { csrfToken: req.csrfToken() });
     });
     
     // Validate CSRF token
     app.post('/process', csrfProtection, (req, res) => {
       // Process the request
     });
     ```

7. **Implement Secure Cookie Settings**
   - Set secure, httpOnly, and sameSite attributes
   - Use appropriate expiration times
   - Example:
     ```javascript
     res.cookie('sessionId', sessionId, {
       httpOnly: true,  // Prevents JavaScript access
       secure: true,    // Only sent over HTTPS
       sameSite: 'strict', // Prevents CSRF attacks
       maxAge: 3600000, // 1 hour
       path: '/',
       domain: 'yourdomain.com'
     });
     ```

8. **Implement Rate Limiting**
   - Apply rate limiting to authentication endpoints
   - Prevent brute force attacks
   - Example with express-rate-limit:
     ```javascript
     const rateLimit = require('express-rate-limit');
     
     const loginLimiter = rateLimit({
       windowMs: 15 * 60 * 1000, // 15 minutes
       max: 5, // 5 attempts per window
       standardHeaders: true,
       legacyHeaders: false,
       message: {
         error: 'Too many login attempts, please try again after 15 minutes'
       }
     });
     
     app.post('/login', loginLimiter, (req, res) => {
       // Handle login
     });
     ```

9. **Implement Proper Session Management**
   - Use secure session management libraries
   - Rotate session IDs after login
   - Example:
     ```javascript
     const session = require('express-session');
     
     app.use(session({
       secret: process.env.SESSION_SECRET,
       resave: false,
       saveUninitialized: false,
       cookie: {
         secure: true,
         httpOnly: true,
         sameSite: 'strict',
         maxAge: 3600000 // 1 hour
       }
     }));
     
     app.post('/login', (req, res) => {
       // Authenticate user
       
       // Regenerate session to prevent session fixation
       req.session.regenerate((err) => {
         if (err) {
           return res.status(500).json({ error: 'Failed to create session' });
         }
         
         // Set authenticated user in session
         req.session.userId = user.id;
         req.session.authenticated = true;
         
         res.json({ success: true });
       });
     });
     ```

10. **Implement Proper Access Control for APIs**
    - Use OAuth 2.0 or JWT for API authentication
    - Implement proper scope checking
    - Example with JWT:
      ```javascript
      const jwt = require('jsonwebtoken');
      
      function verifyToken(req, res, next) {
        const token = req.headers.authorization?.split(' ')[1];
        
        if (!token) {
          return res.status(401).json({ error: 'No token provided' });
        }
        
        try {
          const decoded = jwt.verify(token, process.env.JWT_SECRET);
          req.user = decoded;
          
          // Check if token has required scope
          if (req.route.path === '/api/admin' && !decoded.scopes.includes('admin')) {
            return res.status(403).json({ error: 'Insufficient scope' });
          }
          
          next();
        } catch (error) {
          return res.status(401).json({ error: 'Invalid token' });
        }
      }
      
      // Protect API routes
      app.get('/api/users', verifyToken, (req, res) => {
        // Handle request
      });
      ```

## Validation

- Authentication middleware is implemented correctly.
- Authorization checks are implemented.
- CSRF protection is implemented.
- Secure cookie settings are configured.
- CORS is configured with specific origins rather than wildcards.

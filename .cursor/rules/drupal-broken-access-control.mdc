---
description: Detect and prevent broken access control vulnerabilities in Drupal as defined in OWASP Top 10:2021-A01
globs: *.php, *.install, *.module, *.inc, *.theme
alwaysApply: false
---
# Drupal Broken Access Control Standards (OWASP A01:2021)

Use this checklist to keep Drupal custom code aligned with Drupal's access control APIs and caching rules.

> Priority: high · Version: 1.0 · Tags: security, drupal, access-control, permissions

## Applies To
- `*.php`, `*.module`, `*.install`, `*.inc`, `*.theme`
- Custom modules, themes, and profiles under `modules/`, `themes/`, or `profiles/`

## Trigger Conditions
- Defining routes, controllers, REST resources, or entity operations.
- Manipulating entity fields, files, or configuration values based on user input.
- Calling static helpers such as `\Drupal::currentUser()`, `user_access()`, or bypassing dependency injection.

## Required Checks
- Every route definition must declare access requirements (`_permission`, `_role`, `_entity_access`, or `_custom_access`).
- Controllers and REST resources should return `AccessResult` objects or delegate to access services; never rely on implicit access.
- Use `$account->hasPermission()` or injected `AccountInterface` instead of deprecated `user_access()` or UID checks.
- Before updating or deleting entities, call `$entity->access('<operation>', $account)` and handle forbidden responses explicitly.
- Inject `current_user` and related services instead of calling `\Drupal::currentUser()` statically for better testability and caching.
- Avoid IP-based or static UID bypasses; rely on roles, permissions, and access policies.

## Recommendations
- Implement custom access checkers by extending `AccessCheckInterface` when business rules are complex.
- Ensure access results add cacheability metadata (`addCacheContexts`, `addCacheTags`, `addCacheableDependency`).
- Use `hook_entity_access()` or entity access handlers to centralise policy decisions.
- Document route permissions in README or module docs to aid security reviews.
- Include Behat/Kernel tests that verify unauthorized users cannot reach protected endpoints.

## Positive Signals
- Presence of `AccessResult::allowed()`/`forbidden()` with cache metadata.
- Routes referencing `_entity_access`, `_custom_access`, or `_role` requirements.
- Services injecting `AccountProxyInterface`, `AccessManagerInterface`, or custom checkers.
- Test coverage exercising both success and failure paths for access checks.
